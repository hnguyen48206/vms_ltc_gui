{"ast":null,"code":"import t from \"ramda/es/includes\";\nimport e from \"ramda/es/without\";\nimport { getCssPropertyValue as n } from \"./css.js\";\nimport { transformSpacedStringToArray as r, pluckPixelValue as o } from \"./string.js\";\nimport { isStringAndNotNilOrEmpty as i, isNumericString as u } from \"./identity.js\";\nfunction c(t) {\n  switch (t.tagName.toLowerCase()) {\n    case \"input\":\n      return \"hidden\" !== t.getAttribute(\"type\") && !t.hasAttribute(\"disabled\") && !t.hasAttribute(\"readonly\");\n    case \"button\":\n    case \"select\":\n    case \"textarea\":\n      return !t.hasAttribute(\"disabled\");\n    case \"iframe\":\n    case \"embed\":\n    case \"object\":\n      return !0;\n    case \"a\":\n    case \"area\":\n      return t.hasAttribute(\"href\");\n    case \"audio\":\n    case \"video\":\n      return t.hasAttribute(\"controls\");\n    default:\n      return t.hasAttribute(\"tabindex\") || \"true\" === t.getAttribute(\"contenteditable\") || \"button\" === t.getAttribute(\"role\") && !t.hasAttribute(\"disabled\");\n  }\n}\nfunction a(t) {\n  if (!t) return !1;\n  const e = t.getBoundingClientRect();\n  return e.top < 0 || t.scrollHeight > t.offsetHeight || e.left < 0 || t.scrollWidth > t.clientWidth;\n}\nfunction s(t) {\n  return t.querySelectorAll(f.join(\", \"));\n}\nconst d = [\"a[href]\", \"area[href]\", \"audio[controls]\", \"button:not([disabled])\", 'input:not([type=\"hidden\"]):not([disabled]):not([readonly])', \"iframe\", \"object\", \"embed\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"video[controls]\", \"*[contenteditable=true]\", \"[role=button]:not([disabled])\"],\n  l = [\"*[tabindex]\", ...d],\n  f = ['*[tabindex]:not([tabindex=\"-1\"])', ...d];\nfunction b(t, e = \"px\") {\n  return t && t.getBoundingClientRect ? t.getBoundingClientRect().width + e : \"\";\n}\nfunction h(t, e) {\n  return e ? \"\" : b(t);\n}\nfunction m(t) {\n  return !!t && t instanceof HTMLElement;\n}\nfunction A(t, e) {\n  return !!t && t.hasAttribute(e) && i(t.getAttribute(e));\n}\nfunction g(t, e, n) {\n  const [r, o] = e;\n  n() ? p(t, [r, o]) : y(t, r);\n}\nfunction p(t, ...e) {\n  t && e.forEach(([e, n]) => {\n    !1 === n || null === n ? t.removeAttribute(e) : t.setAttribute(e, n + \"\");\n  });\n}\nfunction y(t, ...e) {\n  t && e.forEach(e => {\n    t.removeAttribute(e);\n  });\n}\nfunction x(e, n, r) {\n  if (e) {\n    const o = e.getAttribute(n);\n    o ? t(r, o.split(\" \")) || e.setAttribute(n, o + \" \" + r) : e.setAttribute(n, r);\n  }\n}\nfunction w(t, n, o) {\n  if (t) {\n    const i = t.getAttribute(n);\n    if (i) {\n      const u = e([o], r(i)).join(\" \");\n      u ? t.setAttribute(n, u) : t.removeAttribute(n);\n    }\n  }\n}\nfunction E(...t) {\n  t.forEach(t => {\n    const [e, n] = t;\n    e && p(e, [\"slot\", n]);\n  });\n}\nfunction C(t) {\n  return !!t && (t === null || t === void 0 ? void 0 : t.offsetHeight) > 0 && !1 === (t === null || t === void 0 ? void 0 : t.hasAttribute(\"hidden\"));\n}\nfunction R(t) {\n  Array.from(t).filter(t => t.textContent && t.textContent.trim().length > 0 && 3 === t.nodeType && t.parentElement).forEach(t => {\n    const e = document.createElement(\"span\");\n    t.after(e), e.appendChild(t);\n  });\n}\nfunction j(t, e) {\n  var _t$shadowRoot;\n  return e && (t.querySelector(e) || (t === null || t === void 0 || (_t$shadowRoot = t.shadowRoot) === null || _t$shadowRoot === void 0 ? void 0 : _t$shadowRoot.querySelector(e))) || null;\n}\nfunction H(t) {\n  return document.createRange().createContextualFragment(t);\n}\nfunction q(t = window) {\n  var _e$documentElement, _e$documentElement2;\n  const e = t === null || t === void 0 ? void 0 : t.document,\n    n = (t === null || t === void 0 ? void 0 : t.innerHeight) || (e === null || e === void 0 || (_e$documentElement = e.documentElement) === null || _e$documentElement === void 0 ? void 0 : _e$documentElement.clientHeight) || 0;\n  return {\n    width: (t === null || t === void 0 ? void 0 : t.innerWidth) || (e === null || e === void 0 || (_e$documentElement2 = e.documentElement) === null || _e$documentElement2 === void 0 ? void 0 : _e$documentElement2.clientWidth) || 0,\n    height: n\n  };\n}\nfunction v(t) {\n  const e = t || n(\"--cds-global-layout-width-xs\").trim();\n  return !!(t !== null && t !== void 0 && t.endsWith(\"px\")) && o(e) >= q().width;\n}\nfunction S(t, e) {\n  const n = e || t;\n  return t.shadowRoot ? t.shadowRoot : n;\n}\nfunction W(t) {\n  return u(t) ? \"number\" : t.match(/^\\d{4}-\\d{1,2}-\\d{1,2}$/) ? \"date\" : \"text\";\n}\nfunction B(t, e) {\n  var _t$shadowRoot2;\n  const n = t.querySelectorAll(e),\n    r = (_t$shadowRoot2 = t.shadowRoot) === null || _t$shadowRoot2 === void 0 ? void 0 : _t$shadowRoot2.querySelectorAll(e);\n  return [...Array.from(n), ...Array.from(r)];\n}\nfunction K(t) {\n  return 2 === t.buttons && !t.ctrlKey || 1 === t.buttons && t.ctrlKey;\n}\nfunction L(t) {\n  return null != t && \"\" + t != \"false\";\n}\nexport { x as addAttributeValue, E as assignSlotNames, L as coerceBooleanProperty, K as contextMenuClick, H as createFragment, l as focusableSelectors, b as getElementWidth, h as getElementWidthUnless, W as getInputValueType, S as getShadowRootOrElse, q as getWindowDimensions, A as hasAttributeAndIsNotEmpty, c as isFocusable, m as isHTMLElement, a as isScrollable, C as isVisible, s as queryAllFocusable, j as queryChildFromLightOrShadowDom, B as querySelectorRoots, w as removeAttributeValue, y as removeAttributes, p as setAttributes, g as setOrRemoveAttribute, R as spanWrapper, f as tabFlowSelectors, v as windowIsAboveMobileBreakpoint };\n//# sourceMappingURL=dom.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}