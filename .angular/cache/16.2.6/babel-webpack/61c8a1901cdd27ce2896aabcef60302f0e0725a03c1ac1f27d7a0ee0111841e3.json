{"ast":null,"code":"function Texture(gl) {\n  this.gl = gl;\n  this.texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, this.texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n}\nTexture.prototype.bind = function (n, program, name) {\n  var gl = this.gl;\n  gl.activeTexture([gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2][n]);\n  gl.bindTexture(gl.TEXTURE_2D, this.texture);\n  gl.uniform1i(gl.getUniformLocation(program, name), n);\n};\nTexture.prototype.fill = function (width, height, data) {\n  var gl = this.gl;\n  gl.bindTexture(gl.TEXTURE_2D, this.texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);\n};\nfunction setupCanvasInternal(canvas, options) {\n  var gl = canvas.getContext(\"webgl\", {\n    preserveDrawingBuffer: Boolean(options.preserveDrawingBuffer)\n  });\n  if (!gl) {\n    console.log('System does not support WebGL');\n    return gl;\n  } else console.log('System supports WebGL');\n  var program = gl.createProgram();\n  var vertexShaderSource = [\"attribute highp vec4 aVertexPosition;\", \"attribute vec2 aTextureCoord;\", \"varying highp vec2 vTextureCoord;\", \"void main(void) {\", \" gl_Position = aVertexPosition;\", \" vTextureCoord = aTextureCoord;\", \"}\"].join(\"\\n\");\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vertexShaderSource);\n  gl.compileShader(vertexShader);\n  var fragmentShaderSource = [\"precision highp float;\", \"varying lowp vec2 vTextureCoord;\", \"uniform sampler2D YTexture;\", \"uniform sampler2D UTexture;\", \"uniform sampler2D VTexture;\", \"const mat4 YUV2RGB = mat4\", \"(\", \" 1.1643828125, 0, 1.59602734375, -.87078515625,\", \" 1.1643828125, -.39176171875, -.81296875, .52959375,\", \" 1.1643828125, 2.017234375, 0, -1.081390625,\", \" 0, 0, 0, 1\", \");\", \"void main(void) {\", \" gl_FragColor = vec4( texture2D(YTexture, vTextureCoord).x, texture2D(UTexture, vTextureCoord).x, texture2D(VTexture, vTextureCoord).x, 1) * YUV2RGB;\", \"}\"].join(\"\\n\");\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fragmentShaderSource);\n  gl.compileShader(fragmentShader);\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  gl.useProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(\"Shader link failed.\");\n  }\n  var vertexPositionAttribute = gl.getAttribLocation(program, \"aVertexPosition\");\n  gl.enableVertexAttribArray(vertexPositionAttribute);\n  var textureCoordAttribute = gl.getAttribLocation(program, \"aTextureCoord\");\n  gl.enableVertexAttribArray(textureCoordAttribute);\n  var verticesBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0]), gl.STATIC_DRAW);\n  gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\n  var texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]), gl.STATIC_DRAW);\n  gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);\n  gl.y = new Texture(gl);\n  gl.u = new Texture(gl);\n  gl.v = new Texture(gl);\n  gl.y.bind(0, program, \"YTexture\");\n  gl.u.bind(1, program, \"UTexture\");\n  gl.v.bind(2, program, \"VTexture\");\n  return gl;\n}\nfunction frameSetup(canvas, gl, width, height) {\n  canvas.width = width;\n  canvas.height = height;\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n}\nfunction renderFrame(gl, videoFrame, width, height, uOffset, vOffset) {\n  gl.y.fill(width, height, videoFrame.subarray(0, uOffset));\n  gl.u.fill(width >> 1, height >> 1, videoFrame.subarray(uOffset, vOffset));\n  gl.v.fill(width >> 1, height >> 1, videoFrame.subarray(vOffset, videoFrame.length));\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n}\nfunction fillBlack(gl) {\n  var arr1 = new Uint8Array(1),\n    arr2 = new Uint8Array(1);\n  arr1[0] = 0;\n  arr2[0] = 128;\n  gl.y.fill(1, 1, arr1);\n  gl.u.fill(1, 1, arr2);\n  gl.v.fill(1, 1, arr2);\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n}\nexport function setupCanvas(canvas, options) {\n  if (!canvas) return;\n  if (typeof canvas === 'string') canvas = window.document.querySelector(canvas);\n  if (!options) {\n    options = {\n      preserveDrawingBuffer: false\n    };\n  }\n  var glContext = setupCanvasInternal(canvas, options);\n  if (!glContext) return;\n  var renderContext = {\n    canvas: canvas,\n    gl: glContext,\n    render: function (videoFrame, width, height, uOffset, vOffset) {\n      if (width != this.canvas.width || height != this.canvas.height) frameSetup(canvas, this.gl, width, height);\n      renderFrame(this.gl, videoFrame, width, height, uOffset, vOffset);\n    },\n    fillBlack: function () {\n      fillBlack(this.gl);\n    }\n  };\n  return renderContext;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}